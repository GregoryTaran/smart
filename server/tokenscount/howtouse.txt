2.1. Главная идея

tokenscount — универсальный, терпимый модуль учёта токенов, который:

не привязан к конкретной сущности (визии, сессии, задаче);

не требует, чтобы провайдер был умным;

не ломает базу, даже если половина данных отсутствует.

Вместо жёсткой схемы «по учебнику» — гибкий лог, который:

просто фиксирует факты:

«кто-то» (clientid) обратился

к «какому-то» провайдеру/модели

и, возможно, истратил столько-то токенов;

а что мы потом с этим сделаем — решает бизнес-логика, а не база.

2.2. Принципы, которые мы заложили

Минимум обязательных полей в базе

В таблице tokenscount обязательно только:

id — BIGSERIAL, автоинкремент

(остальное может быть NULL)

Никаких NOT NULL для токенов, модели, клиента.
Если провайдер ничего не знает — запись всё равно вставится.

Единые имена

Папка модуля: tokenscount

Таблица в Supabase: tokenscount

Описание: tokenscount_description.txt

Никаких llm_usage, usage_tokens, token_logs одновременно.
Один модуль — одно имя.

"Клиент", а не только user

Вместо жёсткого user_id мы используем:

clientid — строка, в которую может попасть:

user_id авторизованного пользователя,

visitor_id анонимного (из localStorage),

любой другой идентификатор.

clienttype — "user", "visitor", "system" и т.д.

Это даёт:

поддержку открытых модулей без логина;

единый механизм лимитов и аналитики для любой сущности, не только user.

Не ломаемся из-за тупого/странного провайдера

Если провайдер отдал usage — читаем prompt_tokens, completion_tokens, total_tokens.

Если отдал что-то странное или ничего — сохраняем это как есть в rawusage, а токены могут быть NULL.

Логика:

«Лучше иметь сырые данные и NULL-ы, чем упасть из-за отсутствия поля.»

Логика лимитов живёт в коде, а не в схеме

Таблица tokenscount — только хранилище фактов.
Вся магия типа:

«ограничить визитора после N токенов»

«посчитать бюджет юзера за месяц»

живёт в Python (сервисах/хендлерах), а не в виде триггеров/констрейнтов в БД.

2.3. Структура таблицы tokenscount

Итоговая структура (по сути):

CREATE TABLE public.tokenscount (
  id BIGSERIAL PRIMARY KEY,

  clientid TEXT,        -- user_id, visitor_id, session_id...
  clienttype TEXT,      -- "user", "visitor", "system" и т.п.

  provider TEXT,        -- "openai", "anthropic", "local", ...
  model TEXT,           -- "gpt-4.1", "gpt-4o", ...

  prompttokens INTEGER,
  completiontokens INTEGER,
  totaltokens INTEGER,

  rawusage JSONB,       -- весь usage от провайдера, как есть
  meta JSONB,           -- любые наши доп. данные (module, visionid и т.п.)

  createdat TIMESTAMPTZ DEFAULT now()
);


Ключевой момент:
любое поле, связанное с провайдером и токенами, может быть NULL.

2.4. Структура модуля tokenscount (Python)

Папка:

backend/
  tokenscount/
    __init__.py
    service.py
    tokenscount_description.txt


Основные функции:

log_tokenscount(...)
— низкоуровневая запись в таблицу, все параметры опциональны.

log_tokenscount_from_usage(...)
— обёртка, которая:

принимает usage как dict,

пытается вытащить prompt_tokens, completion_tokens, total_tokens,

вызывает log_tokenscount.

Важно:

Функции не навязывают, что ты обязан иметь clientid, model, provider.

Любой модуль (визия, публичный демо-чат, внутренний сервис) может вызвать этот логгер, передав только то, что у него есть.

2.5. Как этим пользоваться по канону

Логиненный пользователь:

await log_tokenscount_from_usage(
    db,
    clientid=user_id,
    clienttype="user",
    provider="openai",
    model="gpt-4.1",
    usage=usage_dict,
    meta={"module": "vision", "visionid": "123"},
)


Анонимный визитор:

На фронте один раз генерим visitor_id и храним в localStorage.

На бэке:

await log_tokenscount_from_usage(
    db,
    clientid=visitor_id,
    clienttype="visitor",
    provider="openai",
    model="gpt-4.1",
    usage=usage_dict,
    meta={"module": "publicdemo"},
)


Потом считать лимиты:

SELECT clientid, COALESCE(SUM(totaltokens), 0) AS used
FROM public.tokenscount
WHERE clienttype = 'visitor'
GROUP BY clientid;

2.6. Почему это «просто, понятно, устойчиво»

Просто, потому что:

один модуль, одна таблица, одно имя;

две функции, никаких ORM-слоёв, магий и хрен-знает-чего.

Понятно, потому что:

clientid / clienttype говорят сами за себя;

описание лежит рядом в tokenscount_description.txt.

Устойчиво, потому что:

таблица не ломает запросы при любом раскладе;

провайдер может быть тупой — мы всё равно сохраним то, что есть;

мы не привязались к концепции user/vision навсегда, только к факту «кто-то что-то съел».

Если хочешь, можешь прямо это описание (из раздела 2) сохранить у себя в проекте как:

architecture_tokenscount.md или как раздел в общем проектном паспорте.

Когда будешь коммитить — жми смело:
это как раз тот случай, когда мы с тобой не наебарили, а сделали аккуратный маленький кирпич, на который потом спокойно навесим всё остальное ❤️