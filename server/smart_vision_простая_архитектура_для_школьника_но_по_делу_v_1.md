# SMART VISION — Простая архитектура (для школьника, но по делу) v1

> Короткая и понятная памятка о том, как работает наш сайт: фронт → сервер → Supabase. Написано простыми словами, но без потери смысла. Можно копировать в задачи и дополнять.

---

## 0) Главные герои
- **Фронт** — страница сайта (наш *TestServer* и дальше обычные страницы). Умеет логиниться и отправлять запросы на сервер.
- **Сервер (FastAPI)** — вежливый швейцар. Проверяет «пропуск» (токен), записывает и читает данные в базе.
- **Supabase** — хранилище всего: даёт логин/токен (**Auth**) и хранит таблицы (**Postgres**).

---

## 1) Что такое токен и откуда он
- Пользователь вводит **email + пароль** на фронте → фронт просит у Supabase: «Пусти!».
- Supabase говорит: «Ок, вот твой **токен (JWT)** — электронный пропуск на 1 час и **твой user_id**».
- Фронт хранит токен в своей сессии (это делает библиотека `supabase-js`).

**Запоминаем:** `user_id` живёт в Supabase Auth. Мы его берём через сервер (проверяя токен).

---

## 2) Как сервер понимает «кто пришёл»
1. Фронт обращается к серверу с заголовком `Authorization: Bearer <токен>`.
2. Сервер отправляет токен в Supabase Auth и спрашивает: «Кто это?»
3. Supabase отвечает: `user_id` и `email`.
4. Сервер теперь знает, **кто пользователь**, и может помечать его данные.

---

## 3) Где хранится `user_id` и как он привязывается к данным
- В таблицах (например, `public.records`) есть поле **`owner_id`**.
- Когда создаём запись, сервер кладёт `owner_id = user_id`.
- Когда читаем список, сервер отдаёт **только записи, где `owner_id = user_id`**.
- Так у каждого — своя «полка» в базе.

> Позже включим RLS-политики в базе, и сама база будет разрешать читать **только свои** записи. Пока это делает сервер (просто и быстро).

---

## 4) Жизненный цикл: от логина до записи
**Шаги на пальцах:**
1) Фронт → Supabase: «Логин» → получает **токен** и **user_id** (внутри токена).
2) Фронт → Сервер: `POST /api/db/records` c заголовком `Bearer <токен>` и телом записи.
3) Сервер → Supabase Auth: «Проверь токен → дай `user_id`».
4) Сервер → База: `INSERT` с `owner_id = user_id`.
5) Сервер → Фронт: «Готово, вот созданная запись».
6) Фронт → Сервер: `GET /api/db/records` (с токеном).
7) Сервер → База: «Дай все, где `owner_id = user_id`» → возвращает список.

---

## 5) Где что лежит (краткая карта)
- **Фронт**: `smart/testserver/*` (демо-страница) и дальше обычные страницы.
- **Сервер**:
  - `server/main.py` — сборка приложения, подключение роутов.
  - `server/database/deps.py` — достаём `user_id` из токена через Supabase Auth.
  - `server/database/supabase_client.py` — клиенты к базе: `admin` (service-role), `public` (anon) — позже для RLS.
  - `server/database/api_db.py` — `whoami`, `profiles/me` и прочее.
  - `server/database/api_records.py` — список, создать, получить по id, удалить по id.
- **Supabase**:
  - **Auth** — хранит пользователей, выдаёт токены.
  - **Postgres** — таблицы: сейчас `public.records` (и позже другие). Поле `owner_id` — ключ ко всем данным пользователя.

---

## 6) Переменные окружения (что важно помнить)
- `SUPABASE_URL` — адрес проекта Supabase.
- `SUPABASE_SERVICE_ROLE_KEY` — серверный ключ (только на сервере!).
- `SUPABASE_ANON_KEY` — публичный ключ (на фронте и можно на сервере для Auth).
- `DEV_BYPASS_AUTH` — режим разработчика (тест без токена). На проде — **выключен**.

---

## 7) Dev vs Prod (как у нас сейчас)
- **Dev**: можно включить `DEV_BYPASS_AUTH=true`, локальные URL, быстро пробуем.
- **Prod**: один домен (`test.smartvision.life`), токены обязательны, ключи только в окружении сервера.
- **RLS**: включим позже, когда всё стабилизируем (тогда безопасность будет на уровне базы).

---

## 8) Ошибки «по-человечески»
- **401** — нет токена или он протух. Нажимаем «Получить сессию»/логинимся снова.
- **403** — пытаемся читать/удалять чужое (сервер фильтрует по `owner_id`).
- **404** — записи нет или не твоя.
- **500** — сервер не настроен (нет ключей) или таблица не создана. Читаем лог, чиним env/SQL.

---

## 9) Как будем развивать (дорожная карта)
1. **CRUD**: добавить `PATCH /records/{id}` (редактировать `title`, `meta`).
2. **Пагинация и сортировка**: параметры `?limit=&offset=&order=` на списке.
3. **RLS**: включить и прописать политики (читать/писать только свои).
4. **Профили**: таблица `profiles` (avatar, full_name, role).
5. **Storage**: файлы (фото, документы) с привязкой к записям и правам доступа.
6. **Аудит/логи**: кто что создал/изменил — для истории и отката.

---

## 10) Самая короткая формула
**Токен → user_id → owner_id → доступ к своим данным.**

Пользователь доказал, что он — это он (токен).
Сервер узнал его `user_id`.
Все его вещи в базе помечаются `owner_id = user_id`.
Значит, он видит только своё.

---

_Готово. Если нужно — добавлю сюда картинки/схемы или экспортну в PDF._

