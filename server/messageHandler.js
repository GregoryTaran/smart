import fs from "fs";
import path from "path";

// –ü—É—Ç—å –¥–ª—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
const TMP_DIR = path.join("smart", "translator", "tmp");

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ —Å–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏, –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
if (!fs.existsSync(TMP_DIR)) {
  fs.mkdirSync(TMP_DIR, { recursive: true });
  console.log(`‚úîÔ∏è TMP_DIR created: ${TMP_DIR}`);
} else {
  console.log(`‚úîÔ∏è TMP_DIR already exists: ${TMP_DIR}`);
}

// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —É—Ä–æ–≤–Ω—è–º–∏ –∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏
function logToFile(message, level = "INFO") {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] [${level}] ${message}\n`;
  fs.appendFileSync("server.log", logMessage);
  console.log(logMessage);  // –õ–æ–≥–∏—Ä—É–µ–º –≤ –∫–æ–Ω—Å–æ–ª—å –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
}

// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ Float32Array –≤ WAV
function floatToWav(f32, sampleRate) {
  const buffer = Buffer.alloc(44 + f32.length * 2);
  const view = new DataView(buffer.buffer);
  view.setUint32(0, 0x52494646, false); // "RIFF"
  view.setUint32(4, 36 + f32.length * 2, true); // Chunk size
  view.setUint32(8, 0x57415645, false); // "WAVE"
  view.setUint32(12, 0x666d7420, false); // "fmt "
  view.setUint32(16, 16, true); // Subchunk size
  view.setUint16(20, 1, true); // Audio format (1 = PCM)
  view.setUint16(22, 1, true); // Number of channels (Mono)
  view.setUint32(24, sampleRate, true); // Sample rate
  view.setUint32(28, sampleRate * 2, true); // Byte rate
  view.setUint16(32, 2, true); // Block align
  view.setUint16(34, 16, true); // Bits per sample (16 bits)

  // data header
  view.setUint32(36, 0x64617461, false); // "data"
  view.setUint32(40, f32.length * 2, true); // Data chunk size

  // Audio data
  let offset = 44;
  for (let i = 0; i < f32.length; i++) {
    let s = Math.max(-1, Math.min(1, f32[i]));
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    offset += 2;
  }

  return buffer;
}

// –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ Float32Array –¥–∞–Ω–Ω—ã—Ö
export async function handleBinaryData(ws, data) {
  try {
    logToFile(`üì© Binary data received for session ${ws.sessionId}, length: ${data.length}`, "INFO");

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –±—É—Ñ–µ—Ä
    const buf = Buffer.isBuffer(data) ? data : Buffer.from(data);
    
    // –õ–æ–≥–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞
    logToFile(`üéß Buffer received: ${buf.length} bytes`, "INFO");

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—É—Å—Ç–æ–π –±—É—Ñ–µ—Ä
    if (!buf.length) {
      ws.send("‚ö†Ô∏è Empty binary chunk skipped");
      logToFile(`‚ö†Ô∏è Empty binary chunk skipped for session ${ws.sessionId}`, "WARN");
      return;
    }

    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –±—É—Ñ–µ—Ä –≤ Float32Array
    const f32 = new Float32Array(buf.buffer, buf.byteOffset, Math.floor(buf.byteLength / 4));
    logToFile(`üéß Converted to Float32Array: ${f32.length} samples`, "INFO");

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö
    if (f32.length < 1) {
      ws.send("‚ö†Ô∏è Invalid data length, chunk discarded.");
      logToFile(`‚ö†Ô∏è Invalid data length for session ${ws.sessionId}`, "WARN");
      return;
    }

    // –õ–æ–≥–∏—Ä—É–µ–º –ø–µ—Ä–µ–¥ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–µ–π –≤ WAV
    logToFile(`üéß Preparing WAV conversion for ${f32.length} samples`, "INFO");

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ WAV
    const wav = floatToWav(f32, ws.sampleRate || 44100);
    const filename = `${ws.sessionId}_chunk_${ws.chunkCounter || 0}.wav`;
    ws.chunkCounter = (ws.chunkCounter || 0) + 1;

    // –ü—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞
    const filePath = path.join(TMP_DIR, filename);
    logToFile(`üéß Saving to: ${filePath}`, "INFO");

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º WAV —Ñ–∞–π–ª
    fs.writeFileSync(filePath, wav);
    logToFile(`üíæ Saved ${filename}`, "INFO");
    ws.send(`üíæ Saved ${filename}`);
  } catch (err) {
    logToFile(`‚ùå Binary handler error: ${err.message}`, "ERROR");
    console.error("‚ùå Binary handler error:", err);
    ws.send("‚ùå Binary handler crashed: " + err.message);
  }
}

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
export { handleBinaryData, floatToWav, logToFile };
