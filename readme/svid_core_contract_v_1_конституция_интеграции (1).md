# SVID Core Contract v1

**Цель:** единый и стабильный контракт между ядром идентификации (SVID) и всеми фронтенд‑модулями/страницами. Контракт определяет хранение состояния, события, публичное API, жизненный цикл и правила интеграции.

Версия контракта: **1.0**  
Ответственность за реализацию: **SVID Core (клиент)** + **SVID API (бэкенд)**.

---

## 1) Скоуп и принципы
- **Единственный источник правды:** состояние визитора/пользователя, уровень доступа, токен – ведёт исключительно SVID Core.
- **Детерминированность:** одни и те же входные условия → тот же результат. Все операции идемпотентны.
- **Событийная модель:** UI‑слои слушают события и/или читают снепшот состояния из `getState()`.
- **Независимость модулей:** модули не пишут `svid.*` напрямую; только SVID.
- **Оффлайн‑устойчивость:** минимум – уровень гостя (1) доступен всегда; визитор создаётся/подтверждается при наличии сети.

---

## 2) Ключевые сущности
- **Visitor:** анонимный идентификатор сеанса пользователя (первичный субъект).
- **User:** аутентифицированный субъект (после логина/регистрации).
- **Level:** уровень доступа. Минимум – `1` (гость/визитор), пользователь – `≥2`. Допустимо расширение (3, 10…)

---

## 3) Хранилище (LocalStorage)

SVID Core является **единственным** писателем следующих ключей:

| Ключ                | Тип     | Описание                                                |
|---------------------|---------|---------------------------------------------------------|
| `svid.visitor_id`   | string  | Идентификатор визитора (null/отсутствует до identify)   |
| `svid.visitor_level`| number  | Уровень визитора (обычно 1)                             |
| `svid.user_id`      | string  | Идентификатор пользователя (после логина/регистрации)   |
| `svid.user_level`   | number  | Уровень пользователя (≥2)                               |
| `svid.jwt`          | string  | Токен (если применимо), может отсутствовать             |
| `svid.level`        | number  | Текущий эффективный уровень (≥1)                        |
| `svid.schema`       | number  | Версия схемы LS, для миграций                           |

**Правила:**
- Модулям запрещено изменять `svid.*`.
- Ключ `svid.level` **всегда существует** и ≥ 1. Если сеть недоступна, устанавливается 1 (fallback).
- При логине/логауте `svid.level` синхронизируется с соответствующим уровнем.

---

## 4) События (event bus: `window`)

SVID Core обязан диспетчить события:

| Событие         | Когда происходит                                   | `detail`
|-----------------|------------------------------------------------------|-------------------------------|
| `svid:visitor`  | Создан/подтверждён визитор, либо во время старта     | `{ visitor_id, level }`
| `svid:user`     | Успешный логин/регистрация                           | `{ user_id, level, jwt? }`
| `svid:logout`   | Выход; уровень понижен до визитора                   | `{ level }`
| `svid:level`    | Изменение текущего уровня (любой причиной)           | `{ level }`
| `svid:error`    | Значимые ошибки идентификации/аутентификации         | `{ code?, message }`

**Гарантии:**
- События могут приходить повторно (идемпотентность). Модули обязаны выдерживать повторные рендеры.
- Порядок: при старте сначала создаётся/подтверждается визитор → `svid:visitor` → далее возможны `svid:user` (логин) или `svid:logout`.

---

## 5) Публичное API (клиент)

Экспорт через глобальный синглтон `window.SVID` **и/или** модульные экспорты (в проекте допускается гибрид):

- `SVID.identify(options?) : Promise<Data>` – создать/подтвердить визитора.
- `SVID.register({ display_name?, email?, password?, visitor_id? }) : Promise<Data>`.
- `SVID.login({ email, password }) : Promise<Data>`.
- `SVID.logout() : Promise<{ok:true}>`.
- `SVID.me() : Promise<Data>` – получить профиль (если jwt есть).
- `SVID.getState() : { visitor_id, visitor_level, user_id, user_level, jwt, level }` – **каноничный снепшот**.
- `SVID.ready : Promise<{ level }>` *(опционально)* – resolve после первичной инициализации.
- `SVID.ensureVisitorAndLevel() : Promise<{ visitor_id|null, level, source }>` – гарантирует наличие уровня и визитора.

**Обязательства:** все методы безопасны к повторным вызовам; не создают гонок; не бросают исключения наружу без логгирования.

---

## 6) Жизненный цикл инициализации (страница)

1. **Start:** SVID считывает LS; если `svid.level` отсутствует → ставит `1`.
2. **Visitor ensure:** если нет `svid.visitor_id` → POST `/identify` → сохраняет `visitor_id`, `visitor_level`, поднимает `svid.level` до `visitor_level` (минимум 1), шлёт `svid:visitor`.
3. **User (опционально):** при логине/регистрации сохраняет `user_*`, `jwt`, поднимает `svid.level` и шлёт `svid:user`.
4. **Logout:** сбрасывает `user_*`, устанавливает `svid.level = svid.visitor_level || 1`, шлёт `svid:logout`.

---

## 7) Контракт модулей (UI/страницы)

**Модули ДОЛЖНЫ:**
- На старте прочитать `SVID.getState()` и/или подписаться на `svid:*`.
- Реагировать на `svid:visitor`, `svid:user`, `svid:logout`, `svid:level`.
- Быть идемпотентными (перерисовка допускается многократно).

**Модулям НЕЛЬЗЯ:**
- Писать `svid.*` напрямую; вместо этого вызывать методы SVID.
- Дублировать хранение идентификаторов в других ключах LS (избегать расщепления истины).

**Типовые сценарии:**
- Навигация/меню: фильтрация по `level` (≥2 – показывать пункты для юзера; =1 – гостевое меню).
- Фичи, требующие персонализации: берут `visitor_id`/`jwt` из `SVID.getState()`; не инициируют `/identify` сами.

---

## 8) Ошибки и деградации
- Ошибки сети при `/identify` ≠ падение UI. Минимум: `svid.level = 1`, событие `svid:visitor` с `{ visitor_id:null }`.
- При ошибках логина/регистрации – событие `svid:error` и ненарушенный текущий `level`.

---

## 9) Версионирование и миграции
- Поле `svid.schema` хранит версию схемы LS. При повышении версии SVID сам мигрирует ключи и шлёт `svid:level` (если изменился).
- Обратная совместимость: события и ключи стабильны в рамках минорных версий контракта.

---

## 10) Политика кэширования и SW
- Артефакты ядра (`svid.js`) должны обновляться без застоя: `no-cache`/«stale‑while‑revalidate».
- SW не должен кэшировать ответы `/identify`, `/login`, `/register`, `/logout`.

---

## 11) Мини‑чеклист для новых модулей
- [ ] На старте: `const st = SVID.getState()`; применить `st.level`.
- [ ] Подписаться на события: минимум `svid:level` и `svid:visitor`.
- [ ] Не писать в `svid.*`.
- [ ] Любая логика доступа → через `st.level`.
- [ ] Если нужен backend‑запрос «от имени юзера» → использовать `st.jwt`.

---

## 12) Диагностика
- В консоли: `SVID.getState()` – быстрый снепшот.
- Слушатель: `['svid:visitor','svid:user','svid:logout','svid:level','svid:error'].forEach(ev => window.addEventListener(ev, e => console.log(ev, e.detail)));`
- Проверка LS: `Object.fromEntries(Object.entries(localStorage).filter(([k]) => k.startsWith('svid.')))`

---

### TL;DR
SVID ведёт идентичность и уровень, шлёт события, пишет в `localStorage`. Модули **читают** и **слушают**, не пишут `svid.*`. Так система масштабируется с 2 до 20+ модулей без переписывания и регрессий.



## SVID–Login Contract v1

**Цель:** сделать поведение регистрации/входа/выхода единым и предсказуемым для всех страниц.

### Состояние и события (обязательные гарантийные точки)
- На старте страницы: `svid.level ≥ 1` (гость), `SVID.ready` резолвится после ensure/identify.
- **Регистрация:** `SVID.register()` *не* поднимает уровень и *не* логинит пользователя. Итог: остаёмся на `level=1`, шлём `svid:visitor` (если обновился визитор) и синхронизируем `svid:level` (останется 1).
- **Логин:** `SVID.login()` при успехе:
  - пишет `svid.user_id`, `svid.user_level (≥2)`, `svid.jwt`;
  - поднимает `svid.level = user_level`;
  - диспатчит `svid:user` и `svid:level`.
- **Логаут:** удаляет `user_*` и `jwt`, возвращает `svid.level = svid.visitor_level || 1`, шлёт `svid:logout` и `svid:level`.

### Правила UI для страницы логина (`login.js`)
- Первичная вкладка по умолчанию: **Login**.
- Кнопка «Назад к регистрации» переключает **внутри страницы** на вкладку **Register** (без переходов на другие URL).
- После успешной регистрации: автоматический фокус/переход на вкладку **Login** с подстановкой email (если доступно). **Авто‑логина нет.**
- После успешного входа: редирект на `index.html` (или последний целевой URL, если будет внедрён `returnTo`).
- Ошибки `register/login/reset` отражаются локально, дополнительно SVID шлёт `svid:error { message }` (для глобальных слушателей/телеметрии).

### Контракт действий
- `register({ display_name, email, password })` — возвращает данные сервера; может обновить `visitor`; **не** меняет `user_*`/`level` без валидного `jwt` (мы договорились не использовать `jwt` из register).
- `login({ email, password })` — поднимает `level` до `user_level`, кидает `svid:user` и `svid:level`.
- `reset({ email })` — инициирует восстановление (без изменений уровня).

### Edge‑кейсы
- Нет сети на старте: `SVID.ready` резолвится с `visitor_id: null, level: 1`; UI работает как гостевой, при восстановлении сети визитор обновится через повторный `identify`.
- Повторные события допустимы (идемпотентность): UI обязан корректно перерисовываться.

### Smoke‑тест (страница логина)
1) Чистый профиль → вкладка **Login** активна; `SVID.getState().level === 1`.
2) Register → без изменения `level`; переключение на **Login**.
3) Login → `level` становится `≥2`, прилетают `svid:user` и `svid:level`, редирект на главную, топбар показывает «Выйти».
4) Logout → `level` падает до 1, меню возвращается к гостевому.

---

## SVID–Menu/Topbar Contract v1

**Цель:** топбар/меню всегда адекватно отражают текущий уровень доступа и доступны на всех страницах.

### Истина состояния
- Топбар никогда сам не лезет в сеть за идентификацией; он читает `SVID.getState()` и слушает события.
- Источник отображаемых прав — `svid.level`: `1` (гость), `≥2` (пользователь), возможны расширения (3, 10…).

### События, на которые обязателен подписчик топбара
- `svid:level` — главный триггер перестройки меню/кнопок.
- `svid:visitor` — может обновить отображение `Visitor ID` (если показывается).
- Дополнительно: `storage`, `pageshow` (bfcache), чтобы поймать внешние изменения LS/возвраты по истории.

### Поведение элементов
- Кнопка «Войти/Выйти»: 
  - при `level=1` показывает «Войти», ведёт на `/login/login.html`;
  - при `level≥2` показывает «Выйти», вызывает `SVID.logout()` и после — обновляет меню (redirect опционален).
- Пункты меню фильтруются по `allow: [levels...]` (как реализовано сейчас). При любом изменении уровня происходит полная/частичная перерисовка.

### Инициализация
- Топбар модуль экспортирует `initPage(opts)`. Каждая страница, где требуется меню, **должна вызвать** `initPage()` после подключения SVID.
- `initPage()` дожидается `SVID.ready`, затем рендерит меню согласно текущему `level`, вешает слушателей на `svid:level`, `storage`, `pageshow`.

### Smoke‑тест (страницы с меню)
1) Чистый профиль → меню гостя; кнопка «Войти». 
2) Успешный login → прилетает `svid:level (≥2)` → меню перестраивается, «Выйти» активно.
3) Logout → `level=1` → меню возвращается в гостевой набор.
4) Перезагрузка страницы → состояние меню соответствует `SVID.getState()` без миганий.

---

### TL;DR
- **Login‑страница:** по умолчанию вкладка Login; регистрация не логинит; вход поднимает уровень и диспатчит `svid:user`+`svid:level`.
- **Меню/топбар:** слушают `svid:level` и `svid:visitor`, инициализируются через `initPage()` после `SVID.ready`, отображают «Войти/Выйти»/пункты по текущему уровню.

