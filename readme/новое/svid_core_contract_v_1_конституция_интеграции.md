# SVID Core Contract v1

**Цель:** единый и стабильный контракт между ядром идентификации (SVID) и всеми фронтенд‑модулями/страницами. Контракт определяет хранение состояния, события, публичное API, жизненный цикл и правила интеграции.

Версия контракта: **1.0**  
Ответственность за реализацию: **SVID Core (клиент)** + **SVID API (бэкенд)**.

---

## 1) Скоуп и принципы
- **Единственный источник правды:** состояние визитора/пользователя, уровень доступа, токен – ведёт исключительно SVID Core.
- **Детерминированность:** одни и те же входные условия → тот же результат. Все операции идемпотентны.
- **Событийная модель:** UI‑слои слушают события и/или читают снепшот состояния из `getState()`.
- **Независимость модулей:** модули не пишут `svid.*` напрямую; только SVID.
- **Оффлайн‑устойчивость:** минимум – уровень гостя (1) доступен всегда; визитор создаётся/подтверждается при наличии сети.

---

## 2) Ключевые сущности
- **Visitor:** анонимный идентификатор сеанса пользователя (первичный субъект).
- **User:** аутентифицированный субъект (после логина/регистрации).
- **Level:** уровень доступа. Минимум – `1` (гость/визитор), пользователь – `≥2`. Допустимо расширение (3, 10…)

---

## 3) Хранилище (LocalStorage)

SVID Core является **единственным** писателем следующих ключей:

| Ключ                | Тип     | Описание                                                |
|---------------------|---------|---------------------------------------------------------|
| `svid.visitor_id`   | string  | Идентификатор визитора (null/отсутствует до identify)   |
| `svid.visitor_level`| number  | Уровень визитора (обычно 1)                             |
| `svid.user_id`      | string  | Идентификатор пользователя (после логина/регистрации)   |
| `svid.user_level`   | number  | Уровень пользователя (≥2)                               |
| `svid.jwt`          | string  | Токен (если применимо), может отсутствовать             |
| `svid.level`        | number  | Текущий эффективный уровень (≥1)                        |
| `svid.schema`       | number  | Версия схемы LS, для миграций                           |

**Правила:**
- Модулям запрещено изменять `svid.*`.
- Ключ `svid.level` **всегда существует** и ≥ 1. Если сеть недоступна, устанавливается 1 (fallback).
- При логине/логауте `svid.level` синхронизируется с соответствующим уровнем.

---

## 4) События (event bus: `window`)

SVID Core обязан диспетчить события:

| Событие         | Когда происходит                                   | `detail`
|-----------------|------------------------------------------------------|-------------------------------|
| `svid:visitor`  | Создан/подтверждён визитор, либо во время старта     | `{ visitor_id, level }`
| `svid:user`     | Успешный логин/регистрация                           | `{ user_id, level, jwt? }`
| `svid:logout`   | Выход; уровень понижен до визитора                   | `{ level }`
| `svid:level`    | Изменение текущего уровня (любой причиной)           | `{ level }`
| `svid:error`    | Значимые ошибки идентификации/аутентификации         | `{ code?, message }`

**Гарантии:**
- События могут приходить повторно (идемпотентность). Модули обязаны выдерживать повторные рендеры.
- Порядок: при старте сначала создаётся/подтверждается визитор → `svid:visitor` → далее возможны `svid:user` (логин) или `svid:logout`.

---

## 5) Публичное API (клиент)

Экспорт через глобальный синглтон `window.SVID` **и/или** модульные экспорты (в проекте допускается гибрид):

- `SVID.identify(options?) : Promise<Data>` – создать/подтвердить визитора.
- `SVID.register({ display_name?, email?, password?, visitor_id? }) : Promise<Data>`.
- `SVID.login({ email, password }) : Promise<Data>`.
- `SVID.logout() : Promise<{ok:true}>`.
- `SVID.me() : Promise<Data>` – получить профиль (если jwt есть).
- `SVID.getState() : { visitor_id, visitor_level, user_id, user_level, jwt, level }` – **каноничный снепшот**.
- `SVID.ready : Promise<{ level }>` *(опционально)* – resolve после первичной инициализации.
- `SVID.ensureVisitorAndLevel() : Promise<{ visitor_id|null, level, source }>` – гарантирует наличие уровня и визитора.

**Обязательства:** все методы безопасны к повторным вызовам; не создают гонок; не бросают исключения наружу без логгирования.

---

## 6) Жизненный цикл инициализации (страница)

1. **Start:** SVID считывает LS; если `svid.level` отсутствует → ставит `1`.
2. **Visitor ensure:** если нет `svid.visitor_id` → POST `/identify` → сохраняет `visitor_id`, `visitor_level`, поднимает `svid.level` до `visitor_level` (минимум 1), шлёт `svid:visitor`.
3. **User (опционально):** при логине/регистрации сохраняет `user_*`, `jwt`, поднимает `svid.level` и шлёт `svid:user`.
4. **Logout:** сбрасывает `user_*`, устанавливает `svid.level = svid.visitor_level || 1`, шлёт `svid:logout`.

---

## 7) Контракт модулей (UI/страницы)

**Модули ДОЛЖНЫ:**
- На старте прочитать `SVID.getState()` и/или подписаться на `svid:*`.
- Реагировать на `svid:visitor`, `svid:user`, `svid:logout`, `svid:level`.
- Быть идемпотентными (перерисовка допускается многократно).

**Модулям НЕЛЬЗЯ:**
- Писать `svid.*` напрямую; вместо этого вызывать методы SVID.
- Дублировать хранение идентификаторов в других ключах LS (избегать расщепления истины).

**Типовые сценарии:**
- Навигация/меню: фильтрация по `level` (≥2 – показывать пункты для юзера; =1 – гостевое меню).
- Фичи, требующие персонализации: берут `visitor_id`/`jwt` из `SVID.getState()`; не инициируют `/identify` сами.

---

## 8) Ошибки и деградации
- Ошибки сети при `/identify` ≠ падение UI. Минимум: `svid.level = 1`, событие `svid:visitor` с `{ visitor_id:null }`.
- При ошибках логина/регистрации – событие `svid:error` и ненарушенный текущий `level`.

---

## 9) Версионирование и миграции
- Поле `svid.schema` хранит версию схемы LS. При повышении версии SVID сам мигрирует ключи и шлёт `svid:level` (если изменился).
- Обратная совместимость: события и ключи стабильны в рамках минорных версий контракта.

---

## 10) Политика кэширования и SW
- Артефакты ядра (`svid.js`) должны обновляться без застоя: `no-cache`/«stale‑while‑revalidate».
- SW не должен кэшировать ответы `/identify`, `/login`, `/register`, `/logout`.

---

## 11) Мини‑чеклист для новых модулей
- [ ] На старте: `const st = SVID.getState()`; применить `st.level`.
- [ ] Подписаться на события: минимум `svid:level` и `svid:visitor`.
- [ ] Не писать в `svid.*`.
- [ ] Любая логика доступа → через `st.level`.
- [ ] Если нужен backend‑запрос «от имени юзера» → использовать `st.jwt`.

---

## 12) Диагностика
- В консоли: `SVID.getState()` – быстрый снепшот.
- Слушатель: `['svid:visitor','svid:user','svid:logout','svid:level','svid:error'].forEach(ev => window.addEventListener(ev, e => console.log(ev, e.detail)));`
- Проверка LS: `Object.fromEntries(Object.entries(localStorage).filter(([k]) => k.startsWith('svid.')))`

---

### TL;DR
SVID ведёт идентичность и уровень, шлёт события, пишет в `localStorage`. Модули **читают** и **слушают**, не пишут `svid.*`. Так система масштабируется с 2 до 20+ модулей без переписывания и регрессий.

